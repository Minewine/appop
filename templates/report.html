<!DOCTYPE html>
<html lang="{{ lang }}">
<head>
  <meta charset="UTF-8">
  <title data-i18n="report.page.title">CV Analysis Report - The Metric</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <!-- Add Highlight.js for code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <!-- Add GitHub Markdown CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown.min.css">
  <!-- Add Chart.js for data visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* --- Base & Reset --- */
    :root {
      --primary-dark: #1e3a8a;
      --primary-light: #2563eb;
      --accent-green: #10b981;
      --accent-green-dark: #059669;
      --accent-amber: #f59e0b;
      --accent-amber-dark: #d97706;
      --accent-red: #ef4444;
      --accent-red-dark: #dc2626;
      --neutral-bg-light: #f8f9fa;
      --neutral-bg-white: #ffffff;
      --neutral-border: #e9ecef;
      --text-dark: #1f2937;
      --text-medium: #343a40;
      --text-light: #6c757d;
      --text-white: #ffffff;
      --shadow-color: rgba(0, 0, 0, 0.07);
      --shadow-color-hover: rgba(0, 0, 0, 0.1);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--neutral-bg-light);
      color: var(--text-medium);
      line-height: 1.7;
      overflow-x: hidden;
      font-weight: 400;
    }

    /* --- Containers & Sections --- */
    .container { max-width: 1000px; margin: 0 auto; padding: 0 1.5rem; }
    section { padding: 2rem 0; }
    
    /* --- Header --- */
    header {
      position: relative;
      background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary-light) 100%);
      color: var(--text-white);
      text-align: center;
      padding: 3rem 1.5rem 2rem;
      overflow: hidden;
    }
    header::before, header::after {
        content: ''; position: absolute; border-radius: 50%; opacity: 0.08; z-index: 0; background: var(--text-white);
    }
    header::before { bottom: -60px; left: -60px; width: 220px; height: 220px; }
    header::after { top: 40px; right: -80px; width: 280px; height: 280px; border-radius: 40% 60% 55% 45% / 45% 50% 50% 55%; }

    header h1 {
      font-size: clamp(2rem, 5vw, 2.75rem); font-weight: 800; margin-bottom: 1rem;
      letter-spacing: -0.5px; position: relative; z-index: 1; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    header .subtitle {
      font-size: 1.1rem;
      opacity: 0.85;
      margin-bottom: 1.5rem;
      position: relative;
      z-index: 1;
    }
    header .back-link {
      position: absolute;
      top: 1.5rem;
      left: 1.5rem;
      color: white;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
      opacity: 0.85;
      transition: opacity 0.2s ease;
      z-index: 10;
    }
    header .back-link:hover {
      opacity: 1;
    }
    
    /* --- Markdown Content --- */
    .markdown-body {
      background-color: var(--neutral-bg-white);
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 8px 25px var(--shadow-color);
    }
    
    /* --- Report Info --- */
    .report-info {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    .report-item {
      flex: 1;
      min-width: 200px;
      background-color: var(--neutral-bg-white);
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 4px 15px var(--shadow-color);
    }
    .report-item-label {
      font-size: 0.85rem;
      color: var(--text-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }
    .report-item-value {
      font-weight: 600;
      color: var(--text-dark);
    }
    
    /* --- Score Visualization --- */
    .score-container {
      text-align: center;
      margin: 2rem 0;
    }
    
    .score-circle {
      position: relative;
      width: 160px;
      height: 160px;
      margin: 0 auto;
    }
    
    .score-circle svg {
      transform: rotate(-90deg);
      width: 100%;
      height: 100%;
    }
    
    .score-bg {
      fill: none;
      stroke: #e9ecef;
      stroke-width: 10;
    }
    
    .score-value {
      fill: none;
      stroke-width: 10;
      stroke-linecap: round;
      animation: progress 1s ease-out forwards;
    }
    
    .score-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.2rem;
      font-weight: 800;
      color: var(--text-dark);
    }
    
    @keyframes progress {
      0% {
        stroke-dasharray: 0 314;
      }
    }
    
    .score-label {
      font-size: 1.1rem;
      color: var(--text-medium);
      margin-top: 1rem;
      font-weight: 500;
    }
    
    /* Score color classes */
    .score-low { stroke: var(--accent-red); color: var(--accent-red); }
    .score-medium { stroke: var(--accent-amber); color: var(--accent-amber); }
    .score-high { stroke: var(--accent-green); color: var(--accent-green); }

    /* --- Charts & Data Visualization --- */
    .charts-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 2rem;
      margin: 2rem 0;
    }
    
    .chart-wrapper {
      background-color: var(--neutral-bg-white);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 8px 25px var(--shadow-color);
    }
    
    .chart-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-dark);
      margin-bottom: 1rem;
      text-align: center;
    }
    
    /* --- Stats Grid --- */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 1rem;
      margin: 2rem 0;
    }
    
    .stat-card {
      background-color: var(--neutral-bg-white);
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 4px 15px var(--shadow-color);
      text-align: center;
    }
    
    .stat-value {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--primary-dark);
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: var(--text-light);
      margin-top: 0.5rem;
    }
    
    /* --- Actions --- */
    .actions {
      margin-top: 2.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
    }
    
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 600;
      text-align: center;
      vertical-align: middle;
      cursor: pointer;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      line-height: 1.5;
      border-radius: 6px;
      transition: all 0.2s ease-in-out;
      border: none;
      text-decoration: none;
    }
    
    .btn-primary {
      background-color: var(--primary-light);
      color: var(--text-white);
    }
    
    .btn-primary:hover {
      background-color: var(--primary-dark);
    }
    
    .btn-outline {
      background-color: transparent;
      border: 2px solid var(--primary-light);
      color: var(--primary-light);
    }
    
    .btn-outline:hover {
      background-color: var(--primary-light);
      color: var(--text-white);
    }
    
    /* --- Table of Contents --- */
    .toc {
      background-color: var(--neutral-bg-white);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 8px 25px var(--shadow-color);
      margin-bottom: 2rem;
    }
    
    .toc-title {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--text-dark);
      margin-bottom: 1rem;
    }
    
    .toc-list {
      list-style-type: none;
      padding-left: 0;
    }
    
    .toc-list li {
      margin-bottom: 0.5rem;
    }
    
    .toc-list a {
      color: var(--primary-light);
      text-decoration: none;
      display: inline-block;
      padding: 0.25rem 0;
      font-weight: 500;
    }
    
    .toc-list a:hover {
      color: var(--primary-dark);
      text-decoration: underline;
    }
    
    /* --- Responsive Adjustments --- */
    @media (max-width: 768px) {
      .report-info, .charts-container {
        flex-direction: column;
        grid-template-columns: 1fr;
      }
    }
    
    /* Custom table styles */
    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
    }
    
    .markdown-body table th {
      background-color: #f6f8fa;
      padding: 0.75rem;
      border: 1px solid #e1e4e8;
      font-weight: 600;
      text-align: left;
    }
    
    .markdown-body table td {
      padding: 0.75rem;
      border: 1px solid #e1e4e8;
      vertical-align: top;
    }

    /* Print styles */
    @media print {
      body, html {
        background-color: white;
      }
      
      header {
        padding: 1.5rem;
        background: none;
        color: var(--text-dark);
        text-align: center;
      }
      
      header h1 {
        color: var(--primary-dark);
        text-shadow: none;
      }
      
      header .subtitle {
        color: var(--text-medium);
      }
      
      .container {
        max-width: 100%;
      }
      
      .actions, .back-link {
        display: none;
      }
      
      .markdown-body, .chart-wrapper, .toc {
        box-shadow: none;
        padding: 0;
      }
      
      .report-item, .stat-card {
        box-shadow: none;
        border: 1px solid var(--neutral-border);
      }
    }
  </style>
</head>
<body>
  <header>
    <a href="{{ url_for('analysis.upload', lang=lang) }}" class="back-link">
      <i class="fas fa-arrow-left"></i>
      <span data-i18n="nav.back">Back to Upload</span>
    </a>
    <h1 data-i18n="report.title">CV Analysis Report</h1>
    <p class="subtitle" data-i18n="report.subtitle">Insights and recommendations to improve your CV</p>
  </header>

  <section>
    <div class="container">
      <!-- Report header info -->
      <div class="report-info">
        <div class="report-item">
          <div class="report-item-label" data-i18n="report.cv_file">CV File</div>
          <div class="report-item-value">{{ report.cv_filename }}</div>
        </div>
        
        {% if report.jd_filename %}
        <div class="report-item">
          <div class="report-item-label" data-i18n="report.jd_file">Job Description</div>
          <div class="report-item-value">{{ report.jd_filename }}</div>
        </div>
        {% endif %}
        
        <div class="report-item">
          <div class="report-item-label" data-i18n="report.analysis_type">Analysis Type</div>
          <div class="report-item-value">
            {% if report.analysis_type == 'cv_only' %}
              <span data-i18n="report.type.cv_only">CV Analysis</span>
            {% else %}
              <span data-i18n="report.type.cv_jd">CV-Job Match</span>
            {% endif %}
          </div>
        </div>
        
        <div class="report-item">
          <div class="report-item-label" data-i18n="report.date">Date</div>
          <div class="report-item-value">{{ report.timestamp.split('T')[0] }}</div>
        </div>
      </div>
      
      <!-- Extract and display the score in a fancy visualization -->
      <div class="score-container">
        <div class="score-circle">
          <svg viewBox="0 0 100 100">
            <circle class="score-bg" cx="50" cy="50" r="45"></circle>
            <circle class="score-value" id="score-circle" cx="50" cy="50" r="45"></circle>
          </svg>
          <div class="score-text" id="score-text">--</div>
        </div>
        <div class="score-label">
          {% if report.analysis_type == 'cv_only' %}
            <span data-i18n="report.score.ats">ATS Compatibility Score</span>
          {% else %}
            <span data-i18n="report.score.match">Job Match Score</span>
          {% endif %}
        </div>
      </div>
      
      <!-- Key metrics display -->
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-value" id="keyword-match">--</div>
          <div class="stat-label" data-i18n="report.stats.keywords">Keyword Matches</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="section-count">--</div>
          <div class="stat-label" data-i18n="report.stats.sections">CV Sections</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="gaps-count">--</div>
          <div class="stat-label" data-i18n="report.stats.gaps">Identified Gaps</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="strengths-count">--</div>
          <div class="stat-label" data-i18n="report.stats.strengths">Key Strengths</div>
        </div>
      </div>
      
      <!-- Data visualization charts -->
      {% if report.analysis_type == 'cv_jd' and config.get('FEATURE_CV_JD_COMPARISON_CHART', True) %}
      <div class="charts-container">
        <div class="chart-wrapper">
          <div class="chart-title" data-i18n="report.chart.category">Category Match Analysis</div>
          <canvas id="categoryChart"></canvas>
        </div>
        <div class="chart-wrapper">
          <div class="chart-title" data-i18n="report.chart.keyword">Keyword Distribution</div>
          <canvas id="keywordChart"></canvas>
        </div>
      </div>
      {% endif %}

      <!-- Table of contents generated from the report -->
      <div class="toc">
        <div class="toc-title" data-i18n="report.toc">Report Contents</div>
        <ul class="toc-list" id="tocList">
          <!-- Will be populated by JavaScript -->
        </ul>
      </div>
      
      <!-- Main analysis content -->
      <div class="markdown-body">
        {{ report.result | safe }}
      </div>
      
      <!-- Action buttons -->
      <div class="actions">
        <a href="javascript:window.print()" class="btn btn-outline">
          <i class="fas fa-print"></i>
          <span data-i18n="report.print">Print Report</span>
        </a>
        <a href="{{ url_for('analysis.upload', lang=lang) }}" class="btn btn-primary">
          <i class="fas fa-upload"></i>
          <span data-i18n="report.new_analysis">New Analysis</span>
        </a>
        {% if report.analysis_type == 'cv_jd' %}
        <a href="#" id="compareBtn" class="btn btn-outline">
          <i class="fas fa-chart-bar"></i>
          <span data-i18n="report.compare">Interactive Comparison</span>
        </a>
        {% endif %}
      </div>
    </div>
  </section>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    // Function to extract score from the analysis content
    function extractScore() {
      const resultText = `{{ report.result | safe }}`;
      
      // Look for patterns like "Match Score: 72%" or "Compatibility Score: 72%"
      const scorePattern = /(Match|Compatibility|Overall)\s+(?:Score|Compatibility|Match):?\s*(\d+)[%\s]/i;
      const match = resultText.match(scorePattern);
      
      if (match && match[2]) {
        return parseInt(match[2], 10);
      }
      
      // If no match, try other common patterns
      const fallbackPattern = /Score:?\s*(\d+)[%\s]/i;
      const fallbackMatch = resultText.match(fallbackPattern);
      
      if (fallbackMatch && fallbackMatch[1]) {
        return parseInt(fallbackMatch[1], 10);
      }
      
      // Default score if none found
      return 75;
    }
    
    // Function to extract keyword matches
    function extractKeywordMatches() {
      const resultText = `{{ report.result | safe }}`;
      
      // Look for patterns indicating keyword matches
      const keywordPattern = /(\d+)\s+(?:out of|\/)\s+(\d+)\s+keywords/i;
      const match = resultText.match(keywordPattern);
      
      if (match && match[1] && match[2]) {
        return {
          matched: parseInt(match[1], 10),
          total: parseInt(match[2], 10)
        };
      }
      
      // For percentage-based matches
      const percentPattern = /keyword\s+match.*?(\d+)%/i;
      const percentMatch = resultText.match(percentPattern);
      
      if (percentMatch && percentMatch[1]) {
        const percent = parseInt(percentMatch[1], 10);
        // Rough approximation
        return {
          matched: percent,
          total: 100
        };
      }
      
      return {
        matched: 0,
        total: 0
      };
    }
    
    // Function to count CV sections
    function countSections() {
      const resultText = `{{ report.result | safe }}`;
      // Count section headers (## or higher)
      const sectionPattern = /(?:^|\n)#{2,4}\s+([^\n]+)/g;
      const sections = resultText.match(sectionPattern);
      
      return sections ? sections.length : 0;
    }
    
    // Function to count gaps and strengths
    function countGapsAndStrengths() {
      const resultText = `{{ report.result | safe }}`;
      
      // Count weaknesses/gaps
      const weaknessPatterns = [
        /weakness(?:es)?/gi,
        /gap(?:s)?/gi,
        /miss(?:ing|ed)/gi,
        /lack(?:ing|s)?/gi,
        /improve/gi,
        /not\s+found/gi,
        /weak\s+match/gi
      ];
      
      // Count strengths
      const strengthPatterns = [
        /strength(?:s)?/gi,
        /strong(?:\s+match)?/gi,
        /excellent/gi,
        /impressive/gi,
        /well(?:\-|\s+)(?:presented|formatted|structured)/gi,
        /highlight(?:s|ed)?/gi
      ];
      
      let gapsCount = 0;
      let strengthsCount = 0;
      
      // Count occurrences of weakness patterns
      weaknessPatterns.forEach(pattern => {
        const matches = resultText.match(pattern);
        if (matches) {
          gapsCount += matches.length;
        }
      });
      
      // Count occurrences of strength patterns
      strengthPatterns.forEach(pattern => {
        const matches = resultText.match(pattern);
        if (matches) {
          strengthsCount += matches.length;
        }
      });
      
      // Normalize the counts
      gapsCount = Math.min(Math.max(Math.round(gapsCount / 3), 0), 20);
      strengthsCount = Math.min(Math.max(Math.round(strengthsCount / 3), 0), 20);
      
      return {
        gaps: gapsCount,
        strengths: strengthsCount
      };
    }
    
    // Function to extract categories and their match levels
    function extractCategories() {
      const resultText = `{{ report.result | safe }}`;
      
      // Look for tables with match levels
      const categories = {
        'Technical Skills': 0,
        'Soft Skills': 0,
        'Experience': 0,
        'Education': 0,
        'Certifications': 0
      };
      
      // Try to find match levels in tables
      const categoryPattern = /\|\s*([^|]+)\s*\|\s*(Strong|Partial|Weak|Not Found)\s+Match\s*\|/gi;
      let match;
      let matchCount = 0;
      
      while ((match = categoryPattern.exec(resultText)) !== null) {
        const category = match[1].trim();
        const matchLevel = match[2].toLowerCase();
        
        // Determine which standard category this belongs to
        let standardCategory = '';
        if (/technical|programming|language|tool|software|hard skill/i.test(category)) {
          standardCategory = 'Technical Skills';
        } else if (/soft skill|communication|interpersonal|teamwork/i.test(category)) {
          standardCategory = 'Soft Skills';
        } else if (/experience|work|job|career|professional/i.test(category)) {
          standardCategory = 'Experience';
        } else if (/education|degree|academic|study|university|college/i.test(category)) {
          standardCategory = 'Education';
        } else if (/certification|certificate|qualification|license/i.test(category)) {
          standardCategory = 'Certifications';
        } else {
          // If can't categorize, use Technical Skills as default
          standardCategory = 'Technical Skills';
        }
        
        // Convert match level to percentage
        let matchPercentage = 0;
        if (matchLevel.includes('strong')) {
          matchPercentage = 90;
        } else if (matchLevel.includes('partial')) {
          matchPercentage = 60;
        } else if (matchLevel.includes('weak')) {
          matchPercentage = 30;
        }
        
        // Update category score (average if multiple entries)
        if (categories[standardCategory] > 0) {
          categories[standardCategory] = (categories[standardCategory] + matchPercentage) / 2;
        } else {
          categories[standardCategory] = matchPercentage;
        }
        
        matchCount++;
      }
      
      // If no matches found in tables, try to estimate from context
      if (matchCount === 0) {
        const score = extractScore();
        
        // Distribute the overall score across categories
        for (const category in categories) {
          // Random variation around the overall score
          categories[category] = Math.min(100, Math.max(0, score + (Math.random() * 30 - 15)));
        }
      }
      
      return categories;
    }
    
    // Function to generate keyword data for the chart
    function generateKeywordData() {
      const resultText = `{{ report.result | safe }}`;
      
      // Define keyword categories
      const categories = {
        'Technical': ['programming', 'software', 'technical', 'technology', 'tools', 'languages', 'frameworks', 'database', 'systems'],
        'Experience': ['experience', 'work', 'professional', 'industry', 'project', 'business', 'management'],
        'Education': ['education', 'degree', 'university', 'academic', 'study', 'qualification', 'training'],
        'Soft Skills': ['communication', 'teamwork', 'leadership', 'problem solving', 'time management', 'adaptability']
      };
      
      // Count words in the result text (very basic approach)
      const words = resultText.toLowerCase().match(/\b[a-z]{4,}\b/g) || [];
      const wordCounts = {};
      
      words.forEach(word => {
        wordCounts[word] = (wordCounts[word] || 0) + 1;
      });
      
      // Calculate category counts
      const categoryCounts = {
        'Technical': 0,
        'Experience': 0,
        'Education': 0,
        'Soft Skills': 0,
        'Other': 0
      };
      
      // Assign words to categories
      Object.keys(wordCounts).forEach(word => {
        let assigned = false;
        
        for (const category in categories) {
          if (categories[category].some(keyword => word.includes(keyword) || keyword.includes(word))) {
            categoryCounts[category] += wordCounts[word];
            assigned = true;
            break;
          }
        }
        
        if (!assigned) {
          categoryCounts['Other'] += wordCounts[word];
        }
      });
      
      return categoryCounts;
    }
    
    // Function to set up the circular progress bar
    function setupScoreCircle(score) {
      const circle = document.getElementById('score-circle');
      const scoreText = document.getElementById('score-text');
      
      // Calculate the circumference of the circle
      const radius = circle.getAttribute('r');
      const circumference = 2 * Math.PI * radius;
      
      // Calculate the dash offset based on the score
      const dashOffset = circumference * (1 - score / 100);
      
      // Set the stroke-dasharray and stroke-dashoffset
      circle.style.strokeDasharray = `${circumference} ${circumference}`;
      circle.style.strokeDashoffset = dashOffset;
      
      // Update the score text
      scoreText.textContent = `${score}%`;
      
      // Add the appropriate color class based on score
      if (score < 60) {
        circle.classList.add('score-low');
        scoreText.classList.add('score-low');
      } else if (score < 80) {
        circle.classList.add('score-medium');
        scoreText.classList.add('score-medium');
      } else {
        circle.classList.add('score-high');
        scoreText.classList.add('score-high');
      }
    }
    
    // Function to create and set up the category match chart
    function setupCategoryChart(categories) {
      const ctx = document.getElementById('categoryChart').getContext('2d');
      
      new Chart(ctx, {
        type: 'radar',
        data: {
          labels: Object.keys(categories),
          datasets: [{
            label: 'Match Percentage',
            data: Object.values(categories),
            fill: true,
            backgroundColor: 'rgba(37, 99, 235, 0.2)',
            borderColor: 'rgba(37, 99, 235, 1)',
            pointBackgroundColor: 'rgba(37, 99, 235, 1)',
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: 'rgba(37, 99, 235, 1)'
          }]
        },
        options: {
          elements: {
            line: {
              borderWidth: 3
            }
          },
          scales: {
            r: {
              angleLines: {
                display: true
              },
              suggestedMin: 0,
              suggestedMax: 100
            }
          }
        }
      });
    }
    
    // Function to create and set up the keyword distribution chart
    function setupKeywordChart(keywordData) {
      const ctx = document.getElementById('keywordChart').getContext('2d');
      
      new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: Object.keys(keywordData),
          datasets: [{
            data: Object.values(keywordData),
            backgroundColor: [
              'rgba(37, 99, 235, 0.7)',
              'rgba(16, 185, 129, 0.7)',
              'rgba(245, 158, 11, 0.7)',
              'rgba(239, 68, 68, 0.7)',
              'rgba(107, 114, 128, 0.7)'
            ],
            borderColor: '#ffffff',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'right',
            }
          }
        }
      });
    }
    
    // Function to generate table of contents
    function generateTOC() {
      const content = document.querySelector('.markdown-body');
      const tocList = document.getElementById('tocList');
      const headers = content.querySelectorAll('h1, h2, h3, h4');
      
      headers.forEach((header, index) => {
        // Create an ID for the header if it doesn't have one
        if (!header.id) {
          header.id = `section-${index}`;
        }
        
        // Create list item
        const listItem = document.createElement('li');
        const link = document.createElement('a');
        
        // Indent based on header level
        if (header.tagName === 'H3') {
          listItem.style.paddingLeft = '20px';
        } else if (header.tagName === 'H4') {
          listItem.style.paddingLeft = '40px';
        }
        
        link.href = `#${header.id}`;
        link.textContent = header.textContent;
        
        listItem.appendChild(link);
        tocList.appendChild(listItem);
      });
      
      // If no headers found, hide TOC
      if (headers.length === 0) {
        document.querySelector('.toc').style.display = 'none';
      }
    }
    
    // Convert the markdown to HTML and initialize visualizations
    document.addEventListener('DOMContentLoaded', function() {
      // Render markdown content
      const markdownContent = document.querySelector('.markdown-body');
      markdownContent.innerHTML = marked.parse(markdownContent.innerHTML);
      
      // Apply syntax highlighting
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
      
      // Setup the score circle
      const score = extractScore();
      setupScoreCircle(score);
      
      // Generate TOC
      generateTOC();
      
      // Extract and display metrics
      const keywordMatches = extractKeywordMatches();
      document.getElementById('keyword-match').textContent = keywordMatches.total ? 
        `${keywordMatches.matched}/${keywordMatches.total}` : 
        Math.round(score / 10);
      
      const sectionCount = countSections();
      document.getElementById('section-count').textContent = sectionCount || '6';
      
      const countsData = countGapsAndStrengths();
      document.getElementById('gaps-count').textContent = countsData.gaps || '0';
      document.getElementById('strengths-count').textContent = countsData.strengths || '0';
      
      // Set up charts if available
      const categoryChartElement = document.getElementById('categoryChart');
      const keywordChartElement = document.getElementById('keywordChart');
      
      if (categoryChartElement) {
        const categories = extractCategories();
        setupCategoryChart(categories);
      }
      
      if (keywordChartElement) {
        const keywordData = generateKeywordData();
        setupKeywordChart(keywordData);
      }
      
      // Apply translations
      applyTranslations();
    });
    
    // Translations Object
    const translations = {
      en: {
        "report.page.title": "CV Analysis Report - The Metric",
        "report.title": "CV Analysis Report",
        "report.subtitle": "Insights and recommendations to improve your CV",
        "report.cv_file": "CV File",
        "report.jd_file": "Job Description",
        "report.analysis_type": "Analysis Type",
        "report.type.cv_only": "CV Analysis",
        "report.type.cv_jd": "CV-Job Match",
        "report.date": "Date",
        "report.score.ats": "ATS Compatibility Score",
        "report.score.match": "Job Match Score",
        "report.print": "Print Report",
        "report.new_analysis": "New Analysis",
        "report.compare": "Interactive Comparison",
        "nav.back": "Back to Upload",
        "report.stats.keywords": "Keyword Matches",
        "report.stats.sections": "CV Sections",
        "report.stats.gaps": "Identified Gaps",
        "report.stats.strengths": "Key Strengths",
        "report.chart.category": "Category Match Analysis",
        "report.chart.keyword": "Keyword Distribution",
        "report.toc": "Report Contents"
      },
      fr: {
        "report.page.title": "Rapport d'Analyse de CV - Le Metric",
        "report.title": "Rapport d'Analyse de CV",
        "report.subtitle": "Conseils et recommandations pour améliorer votre CV",
        "report.cv_file": "Fichier CV",
        "report.jd_file": "Description du Poste",
        "report.analysis_type": "Type d'Analyse",
        "report.type.cv_only": "Analyse de CV",
        "report.type.cv_jd": "Correspondance CV-Emploi",
        "report.date": "Date",
        "report.score.ats": "Score de Compatibilité ATS",
        "report.score.match": "Score de Correspondance",
        "report.print": "Imprimer le Rapport",
        "report.new_analysis": "Nouvelle Analyse",
        "report.compare": "Comparaison Interactive",
        "nav.back": "Retour au Téléchargement",
        "report.stats.keywords": "Correspondances de Mots-clés",
        "report.stats.sections": "Sections du CV",
        "report.stats.gaps": "Lacunes Identifiées",
        "report.stats.strengths": "Points Forts",
        "report.chart.category": "Analyse des Catégories",
        "report.chart.keyword": "Distribution des Mots-clés",
        "report.toc": "Table des Matières"
      }
    };

    // Apply translations based on lang parameter
    function applyTranslations() {
      // Get language from URL parameter or use stored preference
      const urlParams = new URLSearchParams(window.location.search);
      let lang = urlParams.get('lang') || localStorage.getItem('lang') || 'en';
      
      // Ensure we have translations for this language, fallback to English
      if (!translations[lang]) {
        lang = 'en';
      }
      
      // Store language preference
      localStorage.setItem('lang', lang);
      document.documentElement.lang = lang;
      
      // Apply translations
      const dictionary = translations[lang];
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.dataset.i18n;
        if (dictionary[key]) {
          if (el.tagName === 'TITLE') {
            document.title = dictionary[key];
          } else {
            el.textContent = dictionary[key];
          }
        }
      });
    }
  </script>
</body>
</html>